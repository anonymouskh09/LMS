{
  "version": 3,
  "sources": ["../../../../src/lib/editor/derivations/notVisibleShapes.ts"],
  "sourcesContent": ["import { computed, isUninitialized } from '@tldraw/state'\nimport { TLShape, TLShapeId } from '@tldraw/tlschema'\nimport { Editor } from '../Editor'\n\n/**\n * Non visible shapes are shapes outside of the viewport page bounds.\n *\n * @param editor - Instance of the tldraw Editor.\n * @returns Incremental derivation of non visible shapes.\n */\nexport function notVisibleShapes(editor: Editor) {\n\tconst emptySet = new Set<TLShapeId>()\n\n\treturn computed<Set<TLShapeId>>('notVisibleShapes', function (prevValue) {\n\t\tconst allShapes = editor.getCurrentPageShapes()\n\t\tconst viewportPageBounds = editor.getViewportPageBounds()\n\t\tconst visibleIds = editor.getShapeIdsInsideBounds(viewportPageBounds)\n\n\t\tlet shape: TLShape | undefined\n\n\t\t// Fast path: if all shapes are visible, return empty set\n\t\tif (visibleIds.size === allShapes.length) {\n\t\t\tif (isUninitialized(prevValue) || prevValue.size > 0) {\n\t\t\t\treturn emptySet\n\t\t\t}\n\t\t\treturn prevValue\n\t\t}\n\n\t\t// First run: compute from scratch\n\t\tif (isUninitialized(prevValue)) {\n\t\t\tconst nextValue = new Set<TLShapeId>()\n\t\t\tfor (let i = 0; i < allShapes.length; i++) {\n\t\t\t\tshape = allShapes[i]\n\t\t\t\tif (visibleIds.has(shape.id)) continue\n\t\t\t\tif (!editor.getShapeUtil(shape.type).canCull(shape)) continue\n\t\t\t\tnextValue.add(shape.id)\n\t\t\t}\n\t\t\treturn nextValue\n\t\t}\n\n\t\t// Subsequent runs: single pass to collect IDs and detect changes\n\t\tconst notVisibleIds: TLShapeId[] = []\n\t\tfor (let i = 0; i < allShapes.length; i++) {\n\t\t\tshape = allShapes[i]\n\t\t\tif (visibleIds.has(shape.id)) continue\n\t\t\tif (!editor.getShapeUtil(shape.type).canCull(shape)) continue\n\t\t\tnotVisibleIds.push(shape.id)\n\t\t}\n\n\t\t// Check if the result changed\n\t\tif (notVisibleIds.length === prevValue.size) {\n\t\t\tlet same = true\n\t\t\tfor (let i = 0; i < notVisibleIds.length; i++) {\n\t\t\t\tif (!prevValue.has(notVisibleIds[i])) {\n\t\t\t\t\tsame = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (same) return prevValue\n\t\t}\n\n\t\treturn new Set(notVisibleIds)\n\t})\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAA0C;AAUnC,SAAS,iBAAiB,QAAgB;AAChD,QAAM,WAAW,oBAAI,IAAe;AAEpC,aAAO,uBAAyB,oBAAoB,SAAU,WAAW;AACxE,UAAM,YAAY,OAAO,qBAAqB;AAC9C,UAAM,qBAAqB,OAAO,sBAAsB;AACxD,UAAM,aAAa,OAAO,wBAAwB,kBAAkB;AAEpE,QAAI;AAGJ,QAAI,WAAW,SAAS,UAAU,QAAQ;AACzC,cAAI,8BAAgB,SAAS,KAAK,UAAU,OAAO,GAAG;AACrD,eAAO;AAAA,MACR;AACA,aAAO;AAAA,IACR;AAGA,YAAI,8BAAgB,SAAS,GAAG;AAC/B,YAAM,YAAY,oBAAI,IAAe;AACrC,eAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AAC1C,gBAAQ,UAAU,CAAC;AACnB,YAAI,WAAW,IAAI,MAAM,EAAE,EAAG;AAC9B,YAAI,CAAC,OAAO,aAAa,MAAM,IAAI,EAAE,QAAQ,KAAK,EAAG;AACrD,kBAAU,IAAI,MAAM,EAAE;AAAA,MACvB;AACA,aAAO;AAAA,IACR;AAGA,UAAM,gBAA6B,CAAC;AACpC,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AAC1C,cAAQ,UAAU,CAAC;AACnB,UAAI,WAAW,IAAI,MAAM,EAAE,EAAG;AAC9B,UAAI,CAAC,OAAO,aAAa,MAAM,IAAI,EAAE,QAAQ,KAAK,EAAG;AACrD,oBAAc,KAAK,MAAM,EAAE;AAAA,IAC5B;AAGA,QAAI,cAAc,WAAW,UAAU,MAAM;AAC5C,UAAI,OAAO;AACX,eAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC9C,YAAI,CAAC,UAAU,IAAI,cAAc,CAAC,CAAC,GAAG;AACrC,iBAAO;AACP;AAAA,QACD;AAAA,MACD;AACA,UAAI,KAAM,QAAO;AAAA,IAClB;AAEA,WAAO,IAAI,IAAI,aAAa;AAAA,EAC7B,CAAC;AACF;",
  "names": []
}
