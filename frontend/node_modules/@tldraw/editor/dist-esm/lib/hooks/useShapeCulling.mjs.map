{
  "version": 3,
  "sources": ["../../../src/lib/hooks/useShapeCulling.tsx"],
  "sourcesContent": ["import { TLShapeId } from '@tldraw/tlschema'\nimport { createContext, useCallback, useContext, useMemo, useRef } from 'react'\nimport { setStyleProperty } from '../utils/dom'\n\ninterface ShapeContainerEntry {\n\tcontainer: HTMLDivElement\n\tbgContainer: HTMLDivElement | null\n\tisCulled: boolean\n}\n\ninterface ShapeCullingContextValue {\n\tregister(\n\t\tid: TLShapeId,\n\t\tcontainer: HTMLDivElement,\n\t\tbgContainer: HTMLDivElement | null,\n\t\tisCulled: boolean\n\t): void\n\tunregister(id: TLShapeId): void\n\tupdateCulling(culledShapes: Set<TLShapeId>): void\n}\n\nconst ShapeCullingContext = createContext<ShapeCullingContextValue | null>(null)\n\n/** @internal */\nexport interface ShapeCullingProviderProps {\n\tchildren: React.ReactNode\n}\n\n/**\n * Provides centralized culling management for shape containers.\n * This allows a single reactor to update all shape display states\n * instead of each shape having its own subscription.\n *\n * @internal\n */\nexport function ShapeCullingProvider({ children }: ShapeCullingProviderProps) {\n\tconst containersRef = useRef(new Map<TLShapeId, ShapeContainerEntry>())\n\n\tconst register = useCallback(\n\t\t(\n\t\t\tid: TLShapeId,\n\t\t\tcontainer: HTMLDivElement,\n\t\t\tbgContainer: HTMLDivElement | null,\n\t\t\tisCulled: boolean\n\t\t) => {\n\t\t\tconst display = isCulled ? 'none' : 'block'\n\t\t\tsetStyleProperty(container, 'display', display)\n\t\t\tsetStyleProperty(bgContainer, 'display', display)\n\n\t\t\tcontainersRef.current.set(id, {\n\t\t\t\tcontainer,\n\t\t\t\tbgContainer,\n\t\t\t\tisCulled,\n\t\t\t})\n\t\t},\n\t\t[]\n\t)\n\n\tconst unregister = useCallback((id: TLShapeId) => {\n\t\tcontainersRef.current.delete(id)\n\t}, [])\n\n\tconst updateCulling = useCallback((culledShapes: Set<TLShapeId>) => {\n\t\tfor (const [id, entry] of containersRef.current) {\n\t\t\tconst shouldBeCulled = culledShapes.has(id)\n\t\t\tif (shouldBeCulled !== entry.isCulled) {\n\t\t\t\tconst display = shouldBeCulled ? 'none' : 'block'\n\t\t\t\tsetStyleProperty(entry.container, 'display', display)\n\t\t\t\tsetStyleProperty(entry.bgContainer, 'display', display)\n\t\t\t\tentry.isCulled = shouldBeCulled\n\t\t\t}\n\t\t}\n\t}, [])\n\n\tconst value = useMemo(\n\t\t() => ({\n\t\t\tregister,\n\t\t\tunregister,\n\t\t\tupdateCulling,\n\t\t}),\n\t\t[register, unregister, updateCulling]\n\t)\n\n\treturn <ShapeCullingContext.Provider value={value}>{children}</ShapeCullingContext.Provider>\n}\n\n/**\n * Hook to access the shape culling context for container registration.\n *\n * @internal\n */\nexport function useShapeCulling(): ShapeCullingContextValue {\n\tconst context = useContext(ShapeCullingContext)\n\tif (!context) {\n\t\tthrow new Error('useShapeCulling must be used within ShapeCullingProvider')\n\t}\n\treturn context\n}\n"],
  "mappings": "AAmFQ;AAlFR,SAAS,eAAe,aAAa,YAAY,SAAS,cAAc;AACxE,SAAS,wBAAwB;AAmBjC,MAAM,sBAAsB,cAA+C,IAAI;AAcxE,SAAS,qBAAqB,EAAE,SAAS,GAA8B;AAC7E,QAAM,gBAAgB,OAAO,oBAAI,IAAoC,CAAC;AAEtE,QAAM,WAAW;AAAA,IAChB,CACC,IACA,WACA,aACA,aACI;AACJ,YAAM,UAAU,WAAW,SAAS;AACpC,uBAAiB,WAAW,WAAW,OAAO;AAC9C,uBAAiB,aAAa,WAAW,OAAO;AAEhD,oBAAc,QAAQ,IAAI,IAAI;AAAA,QAC7B;AAAA,QACA;AAAA,QACA;AAAA,MACD,CAAC;AAAA,IACF;AAAA,IACA,CAAC;AAAA,EACF;AAEA,QAAM,aAAa,YAAY,CAAC,OAAkB;AACjD,kBAAc,QAAQ,OAAO,EAAE;AAAA,EAChC,GAAG,CAAC,CAAC;AAEL,QAAM,gBAAgB,YAAY,CAAC,iBAAiC;AACnE,eAAW,CAAC,IAAI,KAAK,KAAK,cAAc,SAAS;AAChD,YAAM,iBAAiB,aAAa,IAAI,EAAE;AAC1C,UAAI,mBAAmB,MAAM,UAAU;AACtC,cAAM,UAAU,iBAAiB,SAAS;AAC1C,yBAAiB,MAAM,WAAW,WAAW,OAAO;AACpD,yBAAiB,MAAM,aAAa,WAAW,OAAO;AACtD,cAAM,WAAW;AAAA,MAClB;AAAA,IACD;AAAA,EACD,GAAG,CAAC,CAAC;AAEL,QAAM,QAAQ;AAAA,IACb,OAAO;AAAA,MACN;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAAA,IACA,CAAC,UAAU,YAAY,aAAa;AAAA,EACrC;AAEA,SAAO,oBAAC,oBAAoB,UAApB,EAA6B,OAAe,UAAS;AAC9D;AAOO,SAAS,kBAA4C;AAC3D,QAAM,UAAU,WAAW,mBAAmB;AAC9C,MAAI,CAAC,SAAS;AACb,UAAM,IAAI,MAAM,0DAA0D;AAAA,EAC3E;AACA,SAAO;AACR;",
  "names": []
}
